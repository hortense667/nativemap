<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ネイティブマップ 1.0</title>
<style>
  :root { --bg:#fafafa; --grid:#d0d0d0; --axis:#888; --text:#222; }
  html,body{height:100%}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans JP,sans-serif;color:var(--text);background:var(--bg)}
  header{position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid #e5e5e5;display:flex;gap:12px;align-items:center;padding:10px 12px;flex-wrap:wrap}
  header .btn{padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#f7f7f7;cursor:pointer}
  header .btn:active{transform:translateY(1px)}
  header .legend{display:flex;gap:8px;align-items:center;margin-left:auto}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:999px;border:1px solid #ddd;background:#fff;cursor:pointer}
  /* 小さな丸ボタン */
  .chipCircle{ width:28px; height:28px; padding:0; display:inline-flex; align-items:center; justify-content:center; border-radius:999px; }
  .chipCircle .dot{ width:14px; height:14px; border-radius:999px; }
  .chip .dot{width:12px;height:12px;border-radius:999px}
  .chip .dot.blue{background:#4da3ff}.chip .dot.red{background:#ff3333}
  .chip.off{opacity:.35}
  .filters{display:flex; gap:8px; align-items:center; }
  .filters select{padding:6px 8px; border:1px solid #ccc; border-radius:8px; background:#fff;}
  .search{display:flex; gap:6px; align-items:center; margin-left:auto}
  .search input{padding:6px 8px; border:1px solid #ccc; border-radius:8px; min-width:220px}
  .viewport{width:100%;height:calc(100% - 58px);overflow:auto;background:#fff}
  .stage{width:2400px;height:2600px;transform-origin:0 0}
  .tooltip{position:absolute;background:#fff;border:1px solid #ccc;padding:8px 10px;border-radius:8px;box-shadow:0 4px 16px rgba(0,0,0,.08);pointer-events:none;font-size:12px;z-index:20}
  .hint{font-size:12px;color:#666}
  .handle{cursor:ns-resize}
  .axisLabel{font-weight:700;fill:#9a9a9a;font-size:40px;opacity:.6}
  .eventLabel{font-size:13px;fill:#111}
  .eventMulti{fill:#c00}
  .gridMinor{stroke:var(--grid);stroke-width:1}
  .gridMajor{stroke:#b0b0b0;stroke-width:1.5}
  .ageAxis,.birthAxis{stroke:var(--axis);stroke-width:2}
  .ageTickText{font-size:18px;fill:#4a4a4a;font-weight:700}
  .eventColBg{fill:#fafafa}
  .eventColBorder{stroke:#e5e5e5;stroke-width:1}
  .handleLane{fill:#f4f9ff}
  .handleLaneBorder{stroke:#d7e8ff;stroke-width:1}
  .editAreaHint{font-size:12px;fill:#888}
  body.dragging{user-select:none;-webkit-user-select:none}
  /* エディタ（テキスト） */
  .editor{ position:absolute; background:#fff; border:1px solid #ccc; border-radius:10px; box-shadow:0 12px 28px rgba(0,0,0,.18); padding:10px; width:520px; z-index:30; }
  .editor h4{ margin:0 0 6px; font-size:14px; display:flex; align-items:center; gap:8px; justify-content:space-between; }
  .editor .fmt{ font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; color:#555; background:#f4f4f4; border:1px solid #e0e0e0; border-radius:6px; padding:2px 6px; }
  .editor textarea{ width:100%; min-height:200px; font:12px/1.5 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; padding:8px; border:1px solid #d0d0d0; border-radius:8px; box-sizing:border-box; resize:vertical; white-space:pre; }
  .editor .row{ display:flex; gap:8px; justify-content:space-between; align-items:center; margin-top:8px; }
  .editor .row .left{ color:#666; font-size:12px; }
  .editor .row button{ padding:6px 10px; border:1px solid #bbb; border-radius:8px; background:#f5f5f5; cursor:pointer; }
  /* 検索反転 */
  .hlText{ fill:#fff !important; }

  /* モーダル */
  .modalOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; z-index:1000; align-items:center; justify-content:center; }
  .modal{ background:#fff; width:min(880px, calc(100% - 32px)); max-height:84vh; overflow:auto; border-radius:12px; box-shadow:0 24px 80px rgba(0,0,0,.25); }
  .modal header{ position:sticky; top:0; background:#fff; border-bottom:1px solid #eee; padding:12px 16px; display:flex; align-items:center; justify-content:space-between; }
  .modal header h3{ margin:0; font-size:16px; }
  .modal .content{ padding:16px 18px; font-size:14px; line-height:1.8; }
  .modal .content h4{ margin:14px 0 6px; font-size:15px; }
  .modal .content p{ margin:8px 0; }
  .modal .content ul{ margin:6px 0 6px 22px; }
  .modal .content code{ background:#f6f6f6; border:1px solid #e3e3e3; padding:1px 4px; border-radius:4px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .modal footer{ padding:10px 16px 16px; display:flex; justify-content:flex-end; }
  .modal footer .btn{ background:#f6f6f6; border:1px solid #ddd; border-radius:10px; padding:6px 10px; cursor:pointer; }
  .credit{ font-size:12px; color:#777; margin-top:8px; }
</style>
</head>
<body>
  <header>
    <strong style="font-size: 1.5em;">ネイティブマップ 1.0</strong>
    <span class="hint">縦軸：誕生年、横軸：年齢／ラベルクリックで編集／誕生年の丸をドラッグ</span>
    <div class="filters" id="filters">
      <button id="genreFilterBtn" style="padding: 4px 8px; border: 1px solid #ccc; background: #f9f9f9; cursor: pointer; border-radius: 4px;">
        ジャンル選択
      </button>
      <label>重要度
        <select id="filterImp">
          <option value="">すべて</option>
          <option>1</option>
          <option>2</option>
          <option>3</option>
          <option>4</option>
          <option>5</option>
        </select>
      </label>
      <button id="eraBtn" style="padding: 4px 8px; border: 1px solid #ccc; background: #f9f9f9; cursor: pointer; border-radius: 4px;">
        時代区分
      </button>
    </div>
    <div class="search">
      <input id="searchBox" type="text" placeholder="ラベルと注釈を検索" />
      <button class="btn" id="searchBtn">検索</button>
      <button class="btn" id="prevBtn">前</button>
      <button class="btn" id="nextBtn">次</button>
    </div>
    <div class="legend">
      <button class="btn" id="loadCsvBtn" title="CSV/TSVを読み込んで追加">ロード</button>
      <button class="btn" id="syncBtn" title="GitHubと同期">同期</button>
      <button class="btn" id="settingsBtn" title="設定">設定</button>
      <button class="btn" id="helpBtn" title="ヘルプ">ヘルプ</button>
      <input type="file" id="fileInput" accept=".csv,.tsv,text/csv,text/tab-separated-values,text/plain" style="display:none" />
      <button class="chip chipCircle" id="toggleBlue" aria-pressed="true" title="水色ラインの表示／非表示"><span class="dot blue"></span></button>
      <button class="chip chipCircle" id="toggleRed" aria-pressed="true" title="赤色ラインの表示／非表示"><span class="dot red"></span></button>
    </div>
  </header>
  <div class="viewport" id="viewport">
    <svg class="stage" id="stage" xmlns="http://www.w3.org/2000/svg">
      <rect x="0" y="0" width="480" height="2600" class="eventColBg" id="eventColBg"/>
      <line x1="480" y1="0" x2="480" y2="2600" class="eventColBorder"/>
      <g id="grid"></g>
      <g id="decades"></g>
      <g id="events"></g>
      <g id="probe-blue"></g>
      <g id="probe-red"></g>
      <text x="12" y="2580" class="editAreaHint">クリックで編集。1950s～2050sまで上下にスクロール可能。</text>
    </svg>
  </div>
  <div id="tooltip" class="tooltip" style="display:none"></div>
  <div id="editor" class="editor" style="display:none"></div>

  <!-- モーダル（ヘルプ＆エラー） -->
  <div id="modal" class="modalOverlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <header>
        <h3 id="modalTitle">ダイアログ</h3>
      </header>
      <div class="content" id="modalContent"></div>
      <footer><button class="btn" id="modalClose">閉じる</button></footer>
    </div>
  </div>

  <!-- 既定の年表JSON（初回ロード時のみ使用）。以降は localStorage を優先。-->
  <script id="events-json" type="application/json">{
    "1952": [{"label":"テレビ放送開始"}],
    "1956": [{"label":"国産初コンピュータ"}],
    "1960": [{"label":"国鉄予約システム"},{"label":"ミステリーゾーン"}],
    "1963": [{"label":"鉄腕アトム"},{"label":"鉄人28号"}],
    "1966": [{"label":"ウルトラQ"},{"label":"サンダーバード"}],
    "1969": [{"label":"住友銀行キャッシュディスペンサ"},{"label":"アポロ11号・月着陸"}],
    "1971": [{"label":"仮面ライダー"}],
    "1973": [{"label":"『8時だョ！全員集合』視聴率50%"}],
    "1977": [{"label":"Apple IIなど初期マイコン"}],
    "1978": [{"label":"マイコン入り製品次々登場"}],
    "1979": [{"label":"機動戦士ガンダム"}],
    "1983": [{"label":"任天堂ファミコン"}],
    "1984": [{"label":"ドラゴンボール"}],
    "1986": [{"label":"PC-9801VM"},{"label":"ビデオレンタル・AVビデオ"}],
    "1995": [{"label":"新世紀エヴァンゲリオン"},{"label":"GHOST IN THE SHELL 攻殻機動隊"}],
    "1996": [{"label":"パソコン通信流行"},{"label":"女子高生にポケベルブーム"},{"label":"たまごっち"},{"label":"ホンダP2"}],
    "1999": [{"label":"iモード・写メール"},{"label":"MATRIX"}],
    "2001": [{"label":"ヤフー！BB開始"}],
    "2005": [{"label":"YouTube"}],
    "2006": [{"label":"『ぐぐる』が流行語大賞"}],
    "2007": [{"label":"電脳コイル"}],
    "2010": [{"label":"iPhoneブレーク"},{"label":"GAFAの影響力拡大"}],
    "2016": [{"label":"DJI Phantom 4／ドローン"}],
    "2018": [{"label":"Ready Player One"}],
    "2020": [{"label":"VR／メタバース注目"}],
    "2022": [{"label":"ChatGPT／生成AI"}],
    "2023": [{"label":"Web3"}]
  </script>

<script>
(function(){
  const vp=document.getElementById('viewport');
  const stage=document.getElementById('stage');
  const gridG=document.getElementById('grid');
  const decadesG=document.getElementById('decades');
  const eventsG=document.getElementById('events');
  const editor=document.getElementById('editor');
  const genreFilterBtn=document.getElementById('genreFilterBtn');
  const selImp=document.getElementById('filterImp');
  const searchBox=document.getElementById('searchBox');
  const searchBtn=document.getElementById('searchBtn');
  const prevBtn=document.getElementById('prevBtn');
  const nextBtn=document.getElementById('nextBtn');
  const loadCsvBtn=document.getElementById('loadCsvBtn');
  const syncBtn=document.getElementById('syncBtn');
  const settingsBtn=document.getElementById('settingsBtn');
  console.log('settingsBtn:', settingsBtn);
  const helpBtn=document.getElementById('helpBtn');
  const fileInput=document.getElementById('fileInput');
  const eventColBg=document.getElementById('eventColBg');
  const modal=document.getElementById('modal');
  const modalTitle=document.getElementById('modalTitle');
  const modalContent=document.getElementById('modalContent');
  const modalClose=document.getElementById('modalClose');

  const YEAR_MIN=1945, YEAR_MAX=2059, AGE_MAX=100;
  const PX_PER_YEAR=22, PX_PER_AGE=25;
  const LEFT_COL_W=480, DECADE_GUTTER=72, ORIGIN_X=LEFT_COL_W, ORIGIN_Y=40;
  const HANDLE_LANE_W=24; // 狭めたドラッグレーン
  const HANDLE_X = ORIGIN_X - HANDLE_LANE_W/2;
  const LABEL_LEFT_X = DECADE_GUTTER + 2;               // ラベル表示開始位置（左）
  const LABEL_RIGHT_X = ORIGIN_X - HANDLE_LANE_W - 8;   // ラベル表示終了（右）
  const width=ORIGIN_X+PX_PER_AGE*(AGE_MAX+2)+200;
  const height=ORIGIN_Y+PX_PER_YEAR*((YEAR_MAX-YEAR_MIN+1)+3);
  stage.setAttribute('width',width); stage.setAttribute('height',height);
  // クリップパス
  const ns='http://www.w3.org/2000/svg';
  const defs=document.createElementNS(ns,'defs');
  const cpEvents=document.createElementNS(ns,'clipPath'); cpEvents.setAttribute('id','clip-events');
  const cpErect=document.createElementNS(ns,'rect'); cpErect.setAttribute('x', DECADE_GUTTER); cpErect.setAttribute('y', 0); cpErect.setAttribute('width', LEFT_COL_W - DECADE_GUTTER - HANDLE_LANE_W - 4); cpErect.setAttribute('height', height); cpEvents.appendChild(cpErect);
  const cpDec=document.createElementNS(ns,'clipPath'); cpDec.setAttribute('id','clip-decades');
  const cpDrect=document.createElementNS(ns,'rect'); cpDrect.setAttribute('x', 0); cpDrect.setAttribute('y', 0); cpDrect.setAttribute('width', DECADE_GUTTER - 4); cpDrect.setAttribute('height', height); cpDec.appendChild(cpDrect);
  defs.appendChild(cpEvents); defs.appendChild(cpDec); stage.insertBefore(defs, stage.firstChild);
  eventsG.setAttribute('clip-path','url(#clip-events)');
  decadesG.setAttribute('clip-path','url(#clip-decades)');

  // ドラッグ専用レーン（幅24px）を時代で色分け
  function createHandleLaneWithEraColors() {
    const currentDate = new Date();
    const currentYear = currentDate.getFullYear();
    const currentMonth = currentDate.getMonth() + 1; // 0-11 -> 1-12
    const currentDay = currentDate.getDate();
    
    // 令和の現在日付までのY座標を計算
    const reiwaCurrentY = yFromBirthYear(currentYear) + (currentMonth - 1) * (PX_PER_YEAR / 12) + (currentDay - 1) * (PX_PER_YEAR / 365);
    
    // 昭和（1926-1988）
    const showaRect = document.createElementNS(ns, 'rect');
    showaRect.setAttribute('x', ORIGIN_X - HANDLE_LANE_W);
    showaRect.setAttribute('y', yFromBirthYear(1926));
    showaRect.setAttribute('width', HANDLE_LANE_W);
    showaRect.setAttribute('height', yFromBirthYear(1989) - yFromBirthYear(1926));
    showaRect.setAttribute('fill', '#f0f8ff'); // 昭和：淡い青
    stage.insertBefore(showaRect, gridG);
    
    // 平成（1989-2018）
    const heiseiRect = document.createElementNS(ns, 'rect');
    heiseiRect.setAttribute('x', ORIGIN_X - HANDLE_LANE_W);
    heiseiRect.setAttribute('y', yFromBirthYear(1989));
    heiseiRect.setAttribute('width', HANDLE_LANE_W);
    heiseiRect.setAttribute('height', yFromBirthYear(2019) - yFromBirthYear(1989));
    heiseiRect.setAttribute('fill', '#f0fff0'); // 平成：淡い緑
    stage.insertBefore(heiseiRect, gridG);
    
    // 令和（2019-現在）
    const reiwaRect = document.createElementNS(ns, 'rect');
    reiwaRect.setAttribute('x', ORIGIN_X - HANDLE_LANE_W);
    reiwaRect.setAttribute('y', yFromBirthYear(2019));
    reiwaRect.setAttribute('width', HANDLE_LANE_W);
    reiwaRect.setAttribute('height', reiwaCurrentY - yFromBirthYear(2019));
    reiwaRect.setAttribute('fill', '#fff0f0'); // 令和：淡い赤
    stage.insertBefore(reiwaRect, gridG);
    
    // 令和の現在日付以降は白
    if (currentYear < YEAR_MAX) {
      const reiwaFutureRect = document.createElementNS(ns, 'rect');
      reiwaFutureRect.setAttribute('x', ORIGIN_X - HANDLE_LANE_W);
      reiwaFutureRect.setAttribute('y', reiwaCurrentY);
      reiwaFutureRect.setAttribute('width', HANDLE_LANE_W);
      reiwaFutureRect.setAttribute('height', yFromBirthYear(YEAR_MAX + 1) - reiwaCurrentY);
      reiwaFutureRect.setAttribute('fill', '#ffffff'); // 未来：白
      stage.insertBefore(reiwaFutureRect, gridG);
    }
    
    // 境界線
    const laneBorder = document.createElementNS(ns, 'line');
  laneBorder.setAttribute('x1', ORIGIN_X - HANDLE_LANE_W);
  laneBorder.setAttribute('x2', ORIGIN_X - HANDLE_LANE_W);
  laneBorder.setAttribute('y1', 0);
  laneBorder.setAttribute('y2', height);
    laneBorder.setAttribute('class', 'handleLaneBorder');
  stage.insertBefore(laneBorder, gridG);
  }
  
  createHandleLaneWithEraColors();

  function yFromBirthYear(by){return ORIGIN_Y+(by-YEAR_MIN)*PX_PER_YEAR;}
  function xFromAge(age){return ORIGIN_X+age*PX_PER_AGE;}
  function lineEl(x1,y1,x2,y2,cls){let l=document.createElementNS('http://www.w3.org/2000/svg','line');l.setAttribute('x1',x1);l.setAttribute('y1',y1);l.setAttribute('x2',x2);l.setAttribute('y2',y2);if(cls) l.setAttribute('class',cls);return l;}
  function textEl(txt,x,y,cls){let t=document.createElementNS('http://www.w3.org/2000/svg','text');t.textContent=txt;t.setAttribute('x',x);t.setAttribute('y',y);if(cls) t.setAttribute('class',cls);return t;}
  function circleEl(cx,cy,r,cls){let c=document.createElementNS('http://www.w3.org/2000/svg','circle');c.setAttribute('cx',cx);c.setAttribute('cy',cy);c.setAttribute('r',r);if(cls)c.setAttribute('class',cls);return c;}

  // ===== モーダル（共通） =====
  function openModal(title, html){
    modalTitle.textContent=title; modalContent.innerHTML=html; modal.style.display='flex'; modal.setAttribute('aria-hidden','false');
    const prevFocus=document.activeElement; modal.dataset.prevFocusId = prevFocus && prevFocus.id ? prevFocus.id : '';
    modalClose.focus();
  }
  function openModalText(title, text){
    modalTitle.textContent=title; modalContent.textContent=text; modal.style.display='flex'; modal.setAttribute('aria-hidden','false');
    const prevFocus=document.activeElement; modal.dataset.prevFocusId = prevFocus && prevFocus.id ? prevFocus.id : '';
    modalClose.focus();
  }
  function closeModal(){ modal.style.display='none'; modal.setAttribute('aria-hidden','true'); const id=modal.dataset.prevFocusId; if(id){ const el=document.getElementById(id); if(el) el.focus(); } }
  modalClose.addEventListener('click', closeModal);
  modal.addEventListener('click', (e)=>{ if(e.target===modal) closeModal(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.style.display==='flex') closeModal(); });
  function showError(title, errors){
    const text = Array.isArray(errors) ? errors.join('\n') : String(errors||'');
    openModalText(title, text);
  }
  function showInfo(title, html){ openModal(title, html); }

  // ===== 検索ハイライトの状態 =====
  let matches=[]; let matchIndex=-1; let hlRect=null; let hlTarget=null; let clearOnNextMove=false;
  function clearHighlight(soft){ if(hlRect && hlRect.parentNode) hlRect.parentNode.removeChild(hlRect); if(hlTarget) hlTarget.classList.remove('hlText'); hlRect=null; hlTarget=null; if(!soft){ clearOnNextMove=false; } }
  function highlight(el){ clearHighlight(true); const bbox=el.getBBox(); hlRect=document.createElementNS(ns,'rect'); const padX=6, padY=3; hlRect.setAttribute('x', bbox.x - padX); hlRect.setAttribute('y', bbox.y - padY); hlRect.setAttribute('width', bbox.width + padX*2); hlRect.setAttribute('height', bbox.height + padY*2); hlRect.setAttribute('rx', 4); hlRect.setAttribute('fill', '#000'); eventsG.insertBefore(hlRect, el); el.classList.add('hlText'); hlTarget=el; const r=el.getBoundingClientRect(); const rv=vp.getBoundingClientRect(); if(r.top < rv.top || r.bottom > rv.bottom){ vp.scrollTop += (r.top - rv.top) - 80; } clearOnNextMove=true; }

  // ===== JSONロード/セーブ =====
  const LS_KEYS=['timelineEventsV2','timelineEventsV1'];
  const GENRES=['ANI','MAN','GAM','TVP','MOV','NET','HAR','PHE','SOF','TOY','FAS','BOO','MAG','NOV','MUS','UNC'];
  const GENRE_SET=new Set(GENRES);
  function normalizeItem(it){ if(typeof it==='string') return {label: it}; const o={ label: it.label||'' }; if(it.genre) o.genre = String(it.genre).toUpperCase(); if(it.imp!==undefined && it.imp!==null && String(it.imp)!==''){ const n = parseInt(it.imp,10); if(n>=1 && n<=5) o.imp=n; else o.imp=''; } if(it.url) o.url = it.url; if(it.note) o.note = it.note; return o; }
  function normalizeAll(obj){ const out={}; for(const y of Object.keys(obj)){ const arr = Array.isArray(obj[y])? obj[y] : []; out[y] = arr.map(normalizeItem).filter(it=>it.label); } return out; }
  function loadEvents(){ 
    for(const k of LS_KEYS){ 
      try{ 
        const s=localStorage.getItem(k); 
        if(s){ 
          const data = JSON.parse(s);
          if (data.events) {
            // 新しい形式（events + eraSettings）
            eraSettings = data.eraSettings || [];
            console.log('loadEvents: eraSettings読み込み:', eraSettings);
            return normalizeAll(data.events);
          } else {
            // 古い形式（eventsのみ）
            console.log('loadEvents: 古い形式のデータ');
            return normalizeAll(data);
          }
        } 
      }catch(e){} 
    } 
    try{ 
      const txt=document.getElementById('events-json').textContent.trim(); 
      return normalizeAll(JSON.parse(txt)); 
    } catch(e){ 
      console.error('embedded JSON parse failed', e); 
      return {}; 
    } 
  }
  function saveEvents(){ 
    try{ 
      const data = {
        events: events,
        eraSettings: eraSettings
      };
      console.log('saveEvents: ローカルストレージに保存', {
        hasEvents: !!data.events,
        hasEraSettings: !!data.eraSettings,
        eraSettingsLength: data.eraSettings.length,
        eraSettingsContent: data.eraSettings
      });
      localStorage.setItem('timelineEventsV2', JSON.stringify(data)); 
    }catch(e){
      console.error('saveEvents エラー:', e);
    } 
  }

  // ===== 時代区分 =====
  let eraSettings = []; // 時代区分の設定データ

  let events = loadEvents();
  
  // 時代区分データを読み込み（loadEventsで既に読み込まれている場合は上書きしない）
  if (!eraSettings || eraSettings.length === 0) {
    eraSettings = loadEraSettings();
  }
  
  // 自動保存の基準を初期化
  let lastSavedEventsData = JSON.stringify(events);

  // ===== フィルタ =====
  let filterGenre = '';
  let filterImp   = '';
  let selectedGenres = new Set(); // 選択されたジャンルのセット
  
  // 時代区分データの読み込み
  function loadEraSettings() {
    const saved = localStorage.getItem('eraSettings');
    return saved ? JSON.parse(saved) : [];
  }
  
  // 時代区分データの保存
  function saveEraSettings() {
    localStorage.setItem('eraSettings', JSON.stringify(eraSettings));
  }
  
  // 初期化（loadEvents内でeraSettingsが設定されるため、ここでは初期化しない）
  
  // 時代区分設定ポップアップの表示
  function showEraSettingsModal() {
    // 既存のモーダルを閉じる
    closeModal();
    const colorOptions = [
      { value: '#4169E1', label: '青' },
      { value: '#32CD32', label: '緑' },
      { value: '#DC143C', label: '赤' },
      { value: '#FF8C00', label: 'オレンジ' },
      { value: '#8A2BE2', label: '紫' },
      { value: '#00CED1', label: '水色' },
      { value: '#FFD700', label: '黄' },
      { value: '#696969', label: 'グレー' }
    ];
    
    const opacityOptions = [
      { value: '0.1', label: '10%' },
      { value: '0.2', label: '20%' },
      { value: '0.3', label: '30%' },
      { value: '0.4', label: '40%' },
      { value: '0.5', label: '50%' },
      { value: '0.6', label: '60%' },
      { value: '0.7', label: '70%' },
      { value: '0.8', label: '80%' }
    ];
    
    const eraItems = eraSettings.map((era, index) => `
      <div style="border: 1px solid #ddd; margin: 8px 0; padding: 12px; border-radius: 6px; background: #f9f9f9;">
        <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
          <input type="checkbox" id="eraEnabled${index}" ${era.enabled ? 'checked' : ''} style="margin-right: 4px;">
          <label for="eraEnabled${index}" style="font-weight: bold;">表示</label>
        </div>
        <div style="margin-bottom: 8px;">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">時代区分名:</label>
          <input type="text" id="eraName${index}" value="${era.name || ''}" style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px;" placeholder="例：テレビ・マンガ・週刊誌の時代">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
          <div style="flex: 1;">
            <label style="display: block; margin-bottom: 4px; font-weight: bold;">開始年:</label>
            <input type="number" id="eraStart${index}" value="${era.startYear || ''}" style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px;" min="1945" max="2050">
          </div>
          <div style="flex: 1;">
            <label style="display: block; margin-bottom: 4px; font-weight: bold;">終了年:</label>
            <input type="number" id="eraEnd${index}" value="${era.endYear || ''}" style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px;" min="1945" max="2050">
          </div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
          <div style="flex: 1;">
            <label style="display: block; margin-bottom: 4px; font-weight: bold;">塗色:</label>
            <select id="eraColor${index}" style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px;">
              ${colorOptions.map(color => `<option value="${color.value}" ${era.color === color.value ? 'selected' : ''}>${color.label}</option>`).join('')}
            </select>
          </div>
          <div style="flex: 1;">
            <label style="display: block; margin-bottom: 4px; font-weight: bold;">透明度:</label>
            <select id="eraOpacity${index}" style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px;">
              ${opacityOptions.map(opacity => `<option value="${opacity.value}" ${era.opacity === opacity.value ? 'selected' : ''}>${opacity.label}</option>`).join('')}
            </select>
          </div>
        </div>
      </div>
    `).join('');
    
    const modalContent = `
      <div style="max-height: 400px; overflow-y: auto;">
        ${eraItems}
        ${eraSettings.length < 8 ? `
          <div style="border: 2px dashed #ccc; margin: 8px 0; padding: 12px; border-radius: 6px; text-align: center; cursor: pointer;" onclick="addEraItem()">
            + 新しい時代区分を追加
          </div>
        ` : ''}
      </div>
      <div style="margin-top: 16px; display: flex; gap: 8px; justify-content: center;">
        <button onclick="saveEraSettings()" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">保存</button>
      </div>
    `;
    
    openModal('時代区分設定', modalContent);
  }
  
  // 新しい時代区分項目を追加
  function addEraItem() {
    if (eraSettings.length >= 8) return;
    
    eraSettings.push({
      name: '',
      startYear: '',
      endYear: '',
      color: '#4169E1',
      opacity: '0.3',
      enabled: true
    });
    
    showEraSettingsModal();
  }
  
  // 時代区分設定を保存
  function saveEraSettings() {
    const newEraSettings = [];
    
    for (let i = 0; i < eraSettings.length; i++) {
      const enabled = document.getElementById(`eraEnabled${i}`)?.checked || false;
      const name = document.getElementById(`eraName${i}`)?.value || '';
      const startYear = parseInt(document.getElementById(`eraStart${i}`)?.value) || 0;
      const endYear = parseInt(document.getElementById(`eraEnd${i}`)?.value) || 0;
      const color = document.getElementById(`eraColor${i}`)?.value || '#4169E1';
      const opacity = document.getElementById(`eraOpacity${i}`)?.value || '0.3';
      
      if (name && startYear && endYear) {
        newEraSettings.push({
          name,
          startYear,
          endYear,
          color,
          opacity,
          enabled
        });
      }
    }
    
    // 8件を超えた場合は古いものから削除
    if (newEraSettings.length > 8) {
      newEraSettings.splice(8);
    }
    
    eraSettings = newEraSettings;
    console.log('saveEraSettings: eraSettings更新', {
      newEraSettings: newEraSettings,
      length: newEraSettings.length,
      content: newEraSettings
    });
    saveEvents(); // ローカルストレージに保存
    closeModal();
    renderEraBackgrounds();
  }
  
  // 時代区分の背景色を描画
  function renderEraBackgrounds() {
    try {
      console.log('renderEraBackgrounds 開始', { stage: !!stage, gridG: !!gridG, eraSettings });
      
      // 必要な要素が存在するかチェック
      if (!stage || !gridG) {
        console.log('stage または gridG が未定義のため、時代区分背景の描画をスキップ');
        return;
      }
      
      // 既存の時代区分背景とテキストを削除
      const existingEras = document.querySelectorAll('.era-background, .era-text, .era-text-bg');
      console.log('既存の時代区分要素を削除:', existingEras.length);
      existingEras.forEach(el => el.remove());
      
      // 有効な時代区分のみを描画
      const enabledEras = (eraSettings || []).filter(era => era && era.enabled);
      console.log('有効な時代区分:', enabledEras.length, enabledEras);
      
      enabledEras.forEach(era => {
        try {
          const startY = yFromBirthYear(era.startYear);
          const endY = yFromBirthYear(era.endYear + 1); // 終了年の次の年まで
          const height = endY - startY;
          
          console.log('時代区分描画:', era.name, { startYear: era.startYear, endYear: era.endYear, startY, endY, height });
          
          if (height > 0) {
            const eraRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            eraRect.setAttribute('x', ORIGIN_X); // グリッドの開始位置から
            eraRect.setAttribute('y', startY);
            eraRect.setAttribute('width', width - ORIGIN_X); // グリッドエリアの幅
            eraRect.setAttribute('height', height);
            eraRect.setAttribute('fill', era.color || '#4169E1');
            eraRect.setAttribute('opacity', era.opacity || '0.3'); // 設定された透明度を使用
            eraRect.setAttribute('class', 'era-background');
            eraRect.setAttribute('data-era-name', era.name || '');
            
            console.log('時代区分矩形作成:', { x: ORIGIN_X, y: startY, width: width - ORIGIN_X, height, color: era.color });
            
            // グリッドの前に挿入（背景として）
            stage.insertBefore(eraRect, gridG);
            console.log('時代区分矩形をstageに挿入完了');
            
            // 時代区分名を表示するテキストを追加
            if (era.name) {
              const eraText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
              const textX = ORIGIN_X + 10; // 左端から少し内側
              const textY = startY + 20; // 上端から少し下
              
              eraText.setAttribute('x', textX);
              eraText.setAttribute('y', textY);
              eraText.setAttribute('font-size', '12');
              eraText.setAttribute('font-weight', 'bold');
              eraText.setAttribute('fill', '#333');
              eraText.setAttribute('class', 'era-text');
              eraText.setAttribute('data-era-name', era.name);
              eraText.textContent = era.name;
              
              // テキストの背景を追加（読みやすくするため）
              const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
              const textWidth = era.name.length * 8; // 概算の文字幅
              textBg.setAttribute('x', textX - 4);
              textBg.setAttribute('y', textY - 12);
              textBg.setAttribute('width', textWidth + 8);
              textBg.setAttribute('height', 16);
              textBg.setAttribute('fill', 'rgba(255, 255, 255, 0.8)');
              textBg.setAttribute('class', 'era-text-bg');
              
              // 背景を先に挿入
              stage.insertBefore(textBg, gridG);
              // テキストを挿入
              stage.insertBefore(eraText, gridG);
              
              console.log('時代区分名テキスト追加:', era.name, { x: textX, y: textY });
            }
          } else {
            console.log('時代区分の高さが0以下のためスキップ:', height);
          }
        } catch (error) {
          console.error('時代区分の描画エラー:', error, era);
        }
      });
    } catch (error) {
      console.error('renderEraBackgrounds エラー:', error);
    }
  }
  
  // 初期化時に時代区分背景を描画（後で実行）
  
  function passesFilter(it){ 
    // ジャンルフィルタ（複数選択対応）
    if (selectedGenres.size > 0) {
      // ジャンルが設定されていない場合は「その他」（UNC）として扱う
      const itemGenre = String(it.genre || 'UNC');
      if (!selectedGenres.has(itemGenre)) {
        return false;
      }
    }
    // 重要度フィルタ
    if(filterImp){ 
      const thr = parseInt(filterImp,10); 
      const imp = parseInt(it.imp,10); 
      if(isNaN(imp) || imp<thr) return false; 
    } 
    return true; 
  }

  // ===== グリッド =====
  function yFromBirthYear(by){return ORIGIN_Y+(by-YEAR_MIN)*PX_PER_YEAR;}
  function xFromAge(age){return ORIGIN_X+age*PX_PER_AGE;}
  function drawGrid(){
    for(let a=0;a<=AGE_MAX;a+=10){ const x=xFromAge(a); gridG.appendChild(lineEl(x,ORIGIN_Y-10,x,height-20,'gridMajor')); }
    for(let y=YEAR_MIN;y<=YEAR_MAX;y++){ const ypx=yFromBirthYear(y); gridG.appendChild(lineEl(ORIGIN_X,ypx,width-20,ypx,(y%10===0?'gridMajor':'gridMinor'))); if(y%10===0){ const decade=String(y).slice(2,3)+"0s"; const tt=textEl(decade, 36, ypx+18, 'axisLabel'); tt.setAttribute('text-anchor','middle'); decadesG.appendChild(tt); } }
    for(let b=YEAR_MIN; b<=YEAR_MAX; b+=5){ const x0=ORIGIN_X, y0=yFromBirthYear(b); const x1=xFromAge(Math.min(AGE_MAX,YEAR_MAX-b)); const y1=yFromBirthYear(Math.min(YEAR_MAX,b+AGE_MAX)); gridG.appendChild(lineEl(x0,y0,x1,y1,'gridMinor')); }
  }
  
  // 固定位置の年齢軸ラベルを作成
  function createFixedAgeLabels() {
    const fixedAgeContainer = document.createElement('div');
    fixedAgeContainer.id = 'fixed-age-labels';
    fixedAgeContainer.style.cssText = `
      position: fixed;
      top: 58px;
      left: 0;
      right: 0;
      height: 20px;
      pointer-events: none;
      z-index: 5;
    `;
    
    for(let a=0;a<=AGE_MAX;a+=10){
      const x = xFromAge(a);
      const label = document.createElement('div');
      label.textContent = a;
      label.style.cssText = `
        position: absolute;
        left: ${x}px;
        top: 0;
        font-size: 18px;
        font-weight: 700;
        color: #4a4a4a;
        transform: translateX(-50%);
        pointer-events: none;
      `;
      fixedAgeContainer.appendChild(label);
    }
    
    document.body.appendChild(fixedAgeContainer);
  }
  
  // 年齢目盛り数字の背景に白い帯を作成
  function createAgeBand() {
    const bandContainer = document.createElement('div');
    bandContainer.id = 'age-band';
    bandContainer.style.cssText = `
      position: fixed;
      top: 54px;
      left: 0;
      right: 0;
      height: 24Only select repositories"px;
      pointer-events: none;
      z-index: 3;
    `;
    
    // 年齢目盛りエリア全体（0から最大年齢まで）に白い帯を作成
    const ageBand = document.createElement('div');
    ageBand.style.cssText = `
      position: absolute;
      left: ${ORIGIN_X}px;
      top: 0;
      width: ${xFromAge(AGE_MAX) - ORIGIN_X}px;
      height: 20px;
      background: white;
      pointer-events: none;
    `;
    bandContainer.appendChild(ageBand);
    
    document.body.appendChild(bandContainer);
  }
  
  try {
  drawGrid();
    createFixedAgeLabels();
    createAgeBand();
    updateGenreFilterButtonText();
  } catch (error) {
    console.error('初期化エラー:', error);
  }

  const tooltip=document.getElementById('tooltip');
  function positionTooltip(e){const r=vp.getBoundingClientRect();tooltip.style.left=(e.clientX-r.left+14)+'px';tooltip.style.top=(e.clientY-r.top+14)+'px';}

  // ===== 詳細一覧表示 =====
  function showDetailList(year, anchor) {
    clearHighlight();
    const items = (events[year] || []).filter(passesFilter);

    editor.innerHTML = `
      <h4 style="display: flex; align-items: center; justify-content: space-between; margin: 0 0 12px 0; font-size: 16px;">
        <span style="display: flex; align-items: center; gap: 8px;">
          <span style="cursor: pointer; font-size: 18px;" onclick="openYearWikipedia(${year})" title="${year}年のWikipediaページを開く">🌐</span>
          <span>${year}年</span>
        </span>
        <span style="font-size: 11px; color: #666; font-weight: normal;">ドラッグで一覧の順序を変更できます</span>
      </h4>
      <div style="max-height: 400px; overflow-y: auto; width: 500px;" id="detailListContainer">
        ${items.length > 0 ? items.map((item, index) => {
          // 元の配列での実際のインデックスを取得
          const allItems = events[year] || [];
          const actualIndex = allItems.findIndex(originalItem => 
            originalItem.label === item.label && originalItem.genre === item.genre
          );
          return `
          <div class="detail-item" data-year="${year}" data-index="${actualIndex}" style="border: 1px solid #ddd; margin: 8px 0; padding: 12px; border-radius: 6px; background: #f9f9f9; cursor: move; user-select: none;" draggable="true">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div style="flex: 1;">
                <div style="font-weight: bold; margin-bottom: 4px;">${item.label}</div>
                <div style="font-size: 12px; color: #666;">
                  ${item.genre ? `ジャンル: ${item.genre}` : ''}
                  ${item.imp ? ` | 重要度: ${item.imp}` : ''}
                  ${item.note ? ` | 注釈: ${item.note}` : ''}
                </div>
              </div>
              <div style="display: flex; gap: 8px;">
                <button onclick="openUrl('${item.url || ''}')" style="padding: 4px 8px; font-size: 12px;" ${!item.url ? 'disabled' : ''}>🌐</button>
                <button onclick="editItem(${year}, ${actualIndex})" style="padding: 4px 8px; font-size: 12px;">✏️</button>
                <button onclick="deleteItem(${year}, ${actualIndex})" style="padding: 4px 8px; font-size: 12px; color: #d32f2f;">🗑️</button>
              </div>
            </div>
          </div>
        `;
        }).join('') : '<div style="text-align: center; color: #666; padding: 20px;">項目がありません</div>'}
      </div>
      <div class="row">
        <div class="left"></div>
        <div class="right">
          <button id="addBtn">追加</button>
          <button id="closeBtn">閉じる</button>
        </div>
      </div>`;
    
    const r = anchor ? anchor.getBoundingClientRect() : {right: 100, top: 100};
    const rv = vp.getBoundingClientRect();
    let left = r.right - rv.left + 8;
    let top = r.top - rv.top;
    const maxLeft = rv.width - 520;
    if(left > maxLeft) left = Math.max(12, r.left - rv.left - 520);
    
    editor.style.left = left + 'px';
    editor.style.top = top + 'px';
    editor.style.display = 'block';

    function close() { 
      saveEvents();
      renderEvents();
      autoSave();
      editor.style.display = 'none'; 
    }
    editor.querySelector('#addBtn').onclick = () => { addNewItem(year); };
    editor.querySelector('#closeBtn').onclick = close;
    
    // ドラッグ&ドロップイベントを設定
    setupDragAndDrop(year);
  }

  // ===== ドラッグ&ドロップ機能 =====
  function setupDragAndDrop(year) {
    const container = document.getElementById('detailListContainer');
    if (!container) return;
    
    let draggedElement = null;
    let draggedIndex = null;
    
    // ドラッグ開始
    container.addEventListener('dragstart', (e) => {
      if (e.target.classList.contains('detail-item')) {
        draggedElement = e.target;
        draggedIndex = parseInt(e.target.dataset.index);
        e.target.style.opacity = '0.5';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', e.target.outerHTML);
      }
    });
    
    // ドラッグ終了
    container.addEventListener('dragend', (e) => {
      if (e.target.classList.contains('detail-item')) {
        e.target.style.opacity = '';
        draggedElement = null;
        draggedIndex = null;
      }
    });
    
    // ドラッグオーバー
    container.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      
      const afterElement = getDragAfterElement(container, e.clientY);
      if (afterElement == null) {
        container.appendChild(draggedElement);
      } else {
        container.insertBefore(draggedElement, afterElement);
      }
    });
    
    // ドロップ
    container.addEventListener('drop', (e) => {
      e.preventDefault();
      
      if (draggedElement && draggedIndex !== null) {
        const newIndex = Array.from(container.children).indexOf(draggedElement);
        
        if (newIndex !== draggedIndex) {
          // 項目の順序を変更
          const items = events[year] || [];
          const item = items.splice(draggedIndex, 1)[0];
          items.splice(newIndex, 0, item);
          
          // データを保存して画面を更新
          saveEvents();
          renderEvents();
          showDetailList(year, null);
        }
      }
    });
  }
  
  // ドラッグ後の要素位置を取得
  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.detail-item:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  // ===== 詳細一覧の操作関数 =====
  function moveItem(year, index, direction) {
    const items = events[year] || [];
    const newIndex = index + direction;
    if (newIndex < 0 || newIndex >= items.length) return;
    
    // 項目を移動
    const item = items.splice(index, 1)[0];
    items.splice(newIndex, 0, item);
    
    saveEvents();
    renderEvents();
    showDetailList(year, null);
  }

  function openUrl(url) {
    if (url && url.startsWith('http')) {
      window.open(url, '_blank');
    }
  }
  
  function openYearWikipedia(year) {
    // Wikipediaの年ページのURL形式（「年」なし）
    const wikipediaUrl = `https://ja.wikipedia.org/wiki/${year}年`;
    console.log('Wikipedia URL:', wikipediaUrl); // デバッグ用
    window.open(wikipediaUrl, '_blank');
  }

  function editItem(year, index) {
    const items = events[year] || [];
    const item = items[index];
    if (!item) return;
    
    showEditModal(year, index, item);
  }

  function deleteItem(year, index) {
    const items = events[year] || [];
    const item = items[index];
    if (!item) return;
    
    if (confirm(`「${item.label}」を削除しますか？`)) {
      items.splice(index, 1);
      if (items.length === 0) {
        delete events[year];
      }
      saveEvents();
      renderEvents();
      showDetailList(year, null);
    }
  }

  function addNewItem(year) {
    showEditModal(year, -1, { label: '' });
  }

  // 個別編集用ポップアップ
  function showEditModal(year, index, item) {
    clearHighlight();
    
    editor.innerHTML = `
      <h4><span>項目の編集</span></h4>
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">ラベル:</label>
        <input type="text" id="editLabel" value="${item.label || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">ジャンル:</label>
        <select id="editGenre" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
          <option value="">選択してください</option>
          <option value="ANI" ${item.genre === 'ANI' ? 'selected' : ''}>アニメ</option>
          <option value="MAN" ${item.genre === 'MAN' ? 'selected' : ''}>マンガ</option>
          <option value="GAM" ${item.genre === 'GAM' ? 'selected' : ''}>ゲーム</option>
          <option value="TVP" ${item.genre === 'TVP' ? 'selected' : ''}>テレビ番組</option>
          <option value="MOV" ${item.genre === 'MOV' ? 'selected' : ''}>映画</option>
          <option value="NET" ${item.genre === 'NET' ? 'selected' : ''}>インターネット</option>
          <option value="HAR" ${item.genre === 'HAR' ? 'selected' : ''}>ハードウェア</option>
          <option value="PHE" ${item.genre === 'PHE' ? 'selected' : ''}>現象・流行</option>
          <option value="SOF" ${item.genre === 'SOF' ? 'selected' : ''}>ソフトウェア</option>
          <option value="TOY" ${item.genre === 'TOY' ? 'selected' : ''}>おもちゃ</option>
          <option value="FAS" ${item.genre === 'FAS' ? 'selected' : ''}>ファッション</option>
          <option value="BOO" ${item.genre === 'BOO' ? 'selected' : ''}>本</option>
          <option value="MAG" ${item.genre === 'MAG' ? 'selected' : ''}>雑誌</option>
          <option value="NOV" ${item.genre === 'NOV' ? 'selected' : ''}>小説</option>
          <option value="MUS" ${item.genre === 'MUS' ? 'selected' : ''}>音楽</option>
          <option value="UNC" ${item.genre === 'UNC' ? 'selected' : ''}>その他</option>
        </select>
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">重要度:</label>
        <select id="editImp" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
          <option value="">選択してください</option>
          <option value="5" ${item.imp === 5 ? 'selected' : ''}>5 - 時代を代表する重要イベント</option>
          <option value="4" ${item.imp === 4 ? 'selected' : ''}>4 - 大きな影響を与えたイベント</option>
          <option value="3" ${item.imp === 3 ? 'selected' : ''}>3 - 一般的に知られているイベント</option>
          <option value="2" ${item.imp === 2 ? 'selected' : ''}>2 - 特定分野で重要なイベント</option>
          <option value="1" ${item.imp === 1 ? 'selected' : ''}>1 - 参考程度のイベント</option>
        </select>
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">URL:</label>
        <input type="url" id="editUrl" value="${item.url || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" placeholder="https://example.com">
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">注釈:</label>
        <textarea id="editNote" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; height: 80px;" placeholder="補足説明やメモ">${item.note || ''}</textarea>
      </div>
      
      <div class="row">
        <div class="left"></div>
        <div class="right">
          <button id="cancel">キャンセル</button>
          <button id="save">保存</button>
        </div>
      </div>`;
    
    const rv = vp.getBoundingClientRect();
    editor.style.left = (rv.width / 2 - 250) + 'px';
    editor.style.top = (rv.height / 2 - 200) + 'px';
    editor.style.display = 'block';
    editor.style.zIndex = '1000';

    function close() { editor.style.display = 'none'; }
    editor.querySelector('#cancel').onclick = close;
    editor.querySelector('#save').onclick = () => { saveEditItem(year, index); close(); };
  }

  function saveEditItem(year, index) {
    const label = document.getElementById('editLabel').value.trim();
    const genre = document.getElementById('editGenre').value.trim();
    const imp = document.getElementById('editImp').value.trim();
    const url = document.getElementById('editUrl').value.trim();
    const note = document.getElementById('editNote').value.trim();
    
    if (!label) {
      showError('編集エラー', 'ラベルは必須です。');
      return;
    }
    
    // 重複チェック（ラベル・ジャンル組み合わせ）
    const key = `${label}|${genre || ''}`;
    const existingItems = buildLabelGenreSet();
    
    // 編集の場合（index !== -1）は、自分自身との重複は除外
    if (index !== -1) {
      const currentItem = events[year][index];
      const currentKey = `${currentItem.label}|${currentItem.genre || ''}`;
      if (key === currentKey) {
        // 同じラベル・ジャンル組み合わせなので重複チェックをスキップ
      } else if (existingItems.has(key)) {
        showError('重複エラー', `同じラベル・ジャンル組み合わせが既に存在します（${label}${genre ? ` [${genre}]` : ''}）`);
        return;
      }
    } else {
      // 新規追加の場合
      if (existingItems.has(key)) {
        showError('重複エラー', `同じラベル・ジャンル組み合わせが既に存在します（${label}${genre ? ` [${genre}]` : ''}）`);
        return;
      }
    }
    
    if (!events[year]) {
      events[year] = [];
    }
    
    const newItem = { label };
    if (genre) newItem.genre = genre;
    if (imp) newItem.imp = parseInt(imp, 10);
    if (url) newItem.url = url;
    if (note) newItem.note = note;
    
    if (index === -1) {
      // 新しい項目を追加
      events[year].push(newItem);
    } else {
      // 既存の項目を更新
      events[year][index] = newItem;
    }
    
    saveEvents();
    renderEvents();
    autoSave();
  }

  // グローバル関数として公開
  window.moveItem = moveItem;
  window.openUrl = openUrl;
  window.openYearWikipedia = openYearWikipedia;
  window.editItem = editItem;
  window.deleteItem = deleteItem;
  window.addNewItem = addNewItem;
  window.saveEditItem = saveEditItem;

  // ===== 編集UI（テキスト） =====
  function serializeLine(it){ const label=(it.label||'').trim(); const g=(it.genre||'').trim(); const imp=(it.imp===undefined||it.imp===null||String(it.imp)==='')? '' : String(it.imp); const url=(it.url||'').trim(); const note=(it.note||'').trim(); if(!g && !imp && !url && !note) return label; return [label,g,imp,url,note].join(';'); }
  function parseLine(line){ const raw=line.trim(); if(!raw) return null; const parts=raw.split(';'); const label=(parts[0]||'').trim(); if(!label) return null; const genre=(parts[1]||'').trim().toUpperCase(); let imp=(parts[2]||'').trim(); imp = imp? String(Math.min(5, Math.max(1, parseInt(imp,10)))): ''; const url=(parts[3]||'').trim(); const note=(parts[4]||'').trim(); const o={label}; if(genre) o.genre=genre; if(imp) o.imp=imp; if(url) o.url=url; if(note) o.note=note; return o; }
  function validateItem(year, it){ const errs=[]; if(it.genre && !GENRE_SET.has(String(it.genre).toUpperCase())) errs.push(`不正なジャンル: ${it.genre}`); if(it.imp!==undefined && it.imp!=='' && !(parseInt(it.imp,10)>=1 && parseInt(it.imp,10)<=5)) errs.push(`不正な重要度: ${it.imp}`); if(!(Number.isInteger(year) && year>=YEAR_MIN && year<=YEAR_MAX)) errs.push(`年の範囲外: ${year}`); return errs; }
  function linesFromItems(items){ return items.map(serializeLine).join('\n'); }

  function showEditor(year, anchor){
    clearHighlight(); 
    const all = events[year]||[]; 
    const items = all.filter(passesFilter); 
    const note = (filterGenre||filterImp) ? '（現在のフィルタに一致する項目のみ編集対象）' : '';
    
    editor.innerHTML = `
      <h4><span>${year}年の項目一括編集 ${note}</span><span class="fmt">ラベル;ジャンル;重要度;URL;注釈</span></h4>
      <textarea id="edText" placeholder="1行につき1件\n形式：ラベル;ジャンル;重要度;URL;注釈\n例）\n任天堂ファミコン;GAM;5;https://ja.wikipedia.org/wiki/ファミリーコンピュータ;家庭用ゲーム機の革命\nラベル;;;https://example.com;補足メモ\nラベル"></textarea>
      <div class="row">
        <div class="left">保存でJSONに反映／Ctrl+Enterでも保存・Escで閉じる</div>
        <div class="right">
          <button id="cancel">キャンセル</button>
          <button id="save">保存</button>
        </div>
      </div>`;
    
    const ta=editor.querySelector('#edText'); 
    ta.value = linesFromItems(items);
    
    const r=anchor ? anchor.getBoundingClientRect() : {right: 100, top: 100}; 
    const rv=vp.getBoundingClientRect(); 
    let left = r.right - rv.left + 8; 
    let top = r.top - rv.top; 
    const maxLeft = rv.width - 540; 
    if(left > maxLeft) left = Math.max(12, r.left - rv.left - 540);
    
    editor.style.left = left + 'px'; 
    editor.style.top = top + 'px'; 
    editor.style.display='block';

    function close(){ editor.style.display='none'; }
    editor.querySelector('#cancel').onclick = close;
    editor.querySelector('#save').onclick = ()=>{ 
      const lines = ta.value.split(/\n/).map(s=>s.trim()); 
      const subset = lines.map(parseLine).filter(Boolean); 
      const errs=[]; 
      for(const it of subset){ errs.push(...validateItem(year, it)); } 
      if(errs.length){ showError('編集エラー', errs); return; } 
      const allItems = events[year]||[]; 
      const others = allItems.filter(it=> !passesFilter(it)); 
      const merged = [...others, ...subset]; 
      if(merged.length===0) delete events[year]; 
      else events[year]=merged; 
      saveEvents(); 
      renderEvents(); 
      autoSave(); 
      close(); 
    };
    
    ta.addEventListener('keydown', e=>{ 
      if((e.ctrlKey||e.metaKey) && e.key==='Enter'){ editor.querySelector('#save').click(); } 
      if(e.key==='Escape'){ e.preventDefault(); editor.querySelector('#cancel').click(); } 
    });
  }

  // ===== レンダリング（フィルタ適用・単純クリップ） =====
  function renderEvents(){
    eventsG.innerHTML=''; clearHighlight(true);
    // すべてのハイライトクラスを確実にクリア
    document.querySelectorAll('.hlText').forEach(el => el.classList.remove('hlText'));
    const years = Object.keys(events).map(Number).sort((a,b)=>a-b);
    for(const y of years){
      const ypx=yFromBirthYear(y);
      const labels=(events[y]||[]).filter(passesFilter).map(it=>it.label).filter(Boolean);
      if(labels.length===0){ continue; }
      const yearPart = String(y).slice(2);
      const labelsPart = labels.join('／');
      const fullText = `${yearPart} ${labelsPart}`;
      
      // 表示範囲を計算（左端から右端まで）
      const maxWidth = LABEL_RIGHT_X - LABEL_LEFT_X;
      const charWidth = 10; // 文字幅をより大きく見積もり（安全側に）
      const maxChars = Math.floor(maxWidth / charWidth);
      
      // 年部分は必ず表示し、ラベル部分のみ切り取り（すべて右詰め）
      let text;
      const textX = LABEL_RIGHT_X; // 常に右端
      const textAnchor = 'end'; // 常に右詰め
      
      // より厳密な判定：年部分 + スペース + バッファを考慮
      const yearSpaceLength = yearPart.length + 1; // 年 + スペース
      const buffer = 8; // 余裕を持たせる文字数
      const minRequiredChars = yearSpaceLength + buffer;
      
      // 判定条件：年部分が確実に見えるかどうか
      if (fullText.length > maxChars || minRequiredChars > maxChars || labelsPart.length > 15) {
        // 切り取られた場合も右詰めで表示
        const remainingChars = Math.max(0, maxChars - yearSpaceLength - buffer);
        const truncatedLabels = labelsPart.substring(0, remainingChars);
        text = `${yearPart} ${truncatedLabels}`;
      } else {
        text = fullText;
      }
      
      const tx=textEl(text, textX, ypx, 'eventLabel');
      tx.setAttribute('text-anchor', textAnchor);
      tx.setAttribute('dominant-baseline','middle');
      tx.setAttribute('data-year', y);
      if(labels.length>1) tx.classList.add('eventMulti');
      tx.style.cursor='pointer';
      eventsG.appendChild(tx);
      // ツールチップ／クリック
      tx.addEventListener('mouseenter',e=>{ 
        clearHighlight(); 
        tooltip.style.display='block'; 
        const items = (events[y]||[]).filter(passesFilter);
        const tooltipContent = items.map(item => {
          let content = `<li><strong>${item.label}</strong>`;
          if (item.genre) content += ` <span style="color:#666;">[${item.genre}]</span>`;
          if (item.imp) content += ` <span style="color:#666;">★${item.imp}</span>`;
          content += '</li>';
          return content;
        }).join('');
        tooltip.innerHTML=`<strong>${y}年</strong><ul style="margin:4px 0 0 16px;">${tooltipContent}</ul>`; 
        positionTooltip(e); 
      });
      tx.addEventListener('mousemove',positionTooltip);
      tx.addEventListener('mouseleave',()=>{tooltip.style.display='none'});
      tx.addEventListener('click',(e)=>{ tooltip.style.display='none'; showDetailList(y, e.target); });
    }
  }
  
  try {
  renderEvents();
    
    // 初期化時に時代区分背景を描画
    renderEraBackgrounds();
  } catch (error) {
    console.error('レンダリングエラー:', error);
  }

  // ===== 検索 =====
  function doSearch(){ 
    clearHighlight(true); 
    const q=searchBox.value.trim(); 
    if(!q){ 
      matches=[]; 
      matchIndex=-1; 
      // 検索ボックスが空の場合はすべてのハイライトをクリア
      document.querySelectorAll('.hlText').forEach(el => el.classList.remove('hlText'));
      return; 
    } 
    
    console.log('検索クエリ:', q);
    console.log('events:', events);
    
    // ラベルと注釈の両方を検索対象にする
    const searchResults = [];
    for (const year of Object.keys(events)) {
      const items = events[year] || [];
      for (const item of items) {
        const labelMatch = item.label && item.label.toLowerCase().includes(q.toLowerCase());
        const noteMatch = item.note && item.note.toLowerCase().includes(q.toLowerCase());
        if (labelMatch || noteMatch) {
          searchResults.push({ year: parseInt(year), item });
          console.log('マッチした項目:', { year, item, labelMatch, noteMatch });
        }
      }
    }
    
    console.log('検索結果:', searchResults);
    
    // 検索結果に基づいてマッチするラベル要素を取得
    const els=[...eventsG.querySelectorAll('text.eventLabel')]; 
    console.log('表示中のラベル要素:', els.length);
    
    matches=els.filter(el=> {
      const year = parseInt(el.getAttribute('data-year'));
      const displayText = el.textContent;
      const isMatch = searchResults.some(result => 
        result.year === year && displayText.includes(result.item.label)
      );
      if (isMatch) {
        console.log('マッチしたラベル要素:', { year, displayText, matchedLabel: searchResults.find(r => r.year === year && displayText.includes(r.item.label))?.item.label, element: el });
      }
      return isMatch;
    });
    
    console.log('最終的なマッチ数:', matches.length);
    
    matchIndex = matches.length? 0 : -1; 
    if(matchIndex!==-1){ highlight(matches[matchIndex]); } 
  }
  function nextMatch(dir){ if(!matches.length) return; matchIndex=(matchIndex+ (dir>0?1:-1) + matches.length)%matches.length; highlight(matches[matchIndex]); }
  searchBtn.addEventListener('click', doSearch);
  searchBox.addEventListener('keydown', e=>{ if(e.key==='Enter'){ doSearch(); }});
  nextBtn.addEventListener('click', ()=> nextMatch(1));
  prevBtn.addEventListener('click', ()=> nextMatch(-1));
  vp.addEventListener('mousemove', ()=>{ if(clearOnNextMove) { clearHighlight(); } });
  vp.addEventListener('click', ()=>{ if(clearOnNextMove) { clearHighlight(); } });

  // ===== 既存ラベル・ジャンル組み合わせ集合 =====
  function buildLabelGenreSet(){ 
    const s=new Set(); 
    for(const y of Object.keys(events)){ 
      for(const it of (events[y]||[])){ 
        if(it && typeof it.label==='string') {
          const key = `${it.label.trim()}|${it.genre || ''}`;
          s.add(key);
        }
      } 
    } 
    return s; 
  }

  // ===== GitHub同期機能 =====
  let githubConfig = {
    accessToken: '',
    owner: 'hortense667',
    repo: 'nativemap',
    filePath: 'timeline.json'
  };
  
  let githubUser = null;


  // 設定の保存・読み込み
  function saveGitHubConfig() {
    try {
      localStorage.setItem('githubConfig', JSON.stringify(githubConfig));
    } catch (e) {
      console.error('設定の保存に失敗:', e);
    }
  }

  function loadGitHubConfig() {
    try {
      const saved = localStorage.getItem('githubConfig');
      if (saved) {
        githubConfig = { ...githubConfig, ...JSON.parse(saved) };
      }
    } catch (e) {
      console.error('設定の読み込みに失敗:', e);
    }
  }

  // GitHubからデータを読み込み
  async function loadFromGitHub() {
    if (!githubConfig.accessToken) {
      showError('設定エラー', 'GitHubアクセストークンが設定されていません。GitHubでログインしてください。');
      return null;
    }

    try {
      const response = await fetch(`https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`, {
        headers: {
          'Authorization': `Bearer ${githubConfig.accessToken}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });

      if (!response.ok) {
        if (response.status === 404) {
          // ファイルが存在しない場合は空のデータを返す
          return {};
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const responseData = await response.json();
      // GitHub APIのBase64データを正しくデコード
      const binaryString = atob(responseData.content);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      const content = new TextDecoder('utf-8').decode(bytes);
      const data = JSON.parse(content);
      
      if (data.events) {
        // 新しい形式（events + eraSettings）
        eraSettings = data.eraSettings || [];
        return data.events;
      } else {
        // 古い形式（eventsのみ）
        return data;
      }
    } catch (error) {
      showError('読み込みエラー', `GitHubからの読み込みに失敗しました: ${error.message}`);
      return null;
    }
  }

  // GitHubにデータを保存
  async function saveToGitHub(data) {
    if (!githubConfig.accessToken) {
      showError('設定エラー', 'GitHubアクセストークンが設定されていません。');
      return false;
    }

    try {
      console.log('saveToGitHub開始');
      console.log('保存データサイズ:', JSON.stringify(data).length, 'bytes');
      
      // まず現在のファイル情報を取得してSHAを取得
      let sha = null;
      try {
        console.log('既存ファイルのSHAを取得中...');
        const getResponse = await fetch(`https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`, {
          headers: {
            'Authorization': `Bearer ${githubConfig.accessToken}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (getResponse.ok) {
          const fileData = await getResponse.json();
          sha = fileData.sha;
          console.log('SHA取得成功:', sha);
        } else {
          console.log('SHA取得失敗:', getResponse.status, getResponse.statusText);
        }
      } catch (e) {
        // ファイルが存在しない場合はshaはnullのまま
        console.log('ファイルが存在しないか、SHAの取得に失敗:', e);
      }

      // UTF-8文字列を正しくBase64エンコード
      console.log('データをBase64エンコード中...');
      const jsonString = JSON.stringify(data, null, 2);
      const bytes = new TextEncoder().encode(jsonString);
      
      // 大きな配列の場合は分割して処理
      let binaryString = '';
      const chunkSize = 8192; // 8KBずつ処理
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        binaryString += String.fromCharCode(...chunk);
      }
      
      const content = btoa(binaryString);
      console.log('Base64エンコード完了, サイズ:', content.length, 'bytes');
      
      const body = {
        message: `Update timeline data - ${new Date().toISOString()}`,
        content: content
      };

      // SHAが取得できた場合は追加
      if (sha) {
        body.sha = sha;
        console.log('SHAをリクエストボディに追加');
      }

      console.log('GitHub APIにPUTリクエスト送信中...');
      const response = await fetch(`https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${githubConfig.accessToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
      });

      console.log('GitHub APIレスポンス:', response.status, response.statusText);

      if (!response.ok) {
        const errorData = await response.json();
        console.error('GitHub APIエラー詳細:', errorData);
        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorData.message || ''}`);
      }

      console.log('saveToGitHub完了');
      return true;
    } catch (error) {
      console.error('saveToGitHubエラー詳細:', error);
      showError('保存エラー', `GitHubへの保存に失敗しました: ${error.message}`);
      return false;
    }
  }

  // 同期処理（確認ダイアログなし）
  async function syncWithConfirmation() {
    await syncWithGitHub();
  }

  // 同期処理
  async function syncWithGitHub() {
    try {
      console.log('同期処理開始');
      console.log('ローカルデータサイズ:', JSON.stringify(events).length, 'bytes');
      
      // 1. GitHubからデータを読み込み
      console.log('GitHubからデータを読み込み中...');
      const remoteData = await loadFromGitHub();
      if (remoteData === null) {
        console.log('リモートデータの読み込みに失敗');
        return;
      }

      // リモートのeraSettingsも取得
      const remoteEraSettings = await fetch(`https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`, {
        headers: {
          'Authorization': `Bearer ${githubConfig.accessToken}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      }).then(response => response.json()).then(responseData => {
        const binaryString = atob(responseData.content);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        const content = new TextDecoder('utf-8').decode(bytes);
        const data = JSON.parse(content);
        return data.eraSettings || [];
      }).catch(() => []);

      console.log('同期開始 - リモートデータ:', remoteData);
      console.log('同期開始 - ローカルデータ:', events);
      console.log('同期開始 - リモートeraSettings:', remoteEraSettings);
      console.log('同期開始 - ローカルeraSettings:', eraSettings);

      // 2. ローカルデータとマージ（順序を保持）
      const localData = events;
      const merged = { ...remoteData };

      // ローカルの変更をリモートに反映（順序を保持）
      for (const [year, localItems] of Object.entries(localData)) {
        if (!merged[year]) {
          merged[year] = [];
        }
        
        // ローカルの項目リストでリモートを完全に置き換え（順序を保持）
        // ただし、リモートにあってローカルにない項目は保持
        const remoteItems = merged[year] || [];
        const localItemKeys = new Set(localItems.map(item => `${item.label}|${item.genre || ''}`));
        
        // リモートにあってローカルにない項目を保持
        const remoteOnlyItems = remoteItems.filter(remoteItem => 
          !localItemKeys.has(`${remoteItem.label}|${remoteItem.genre || ''}`)
        );
        
        // ローカルの項目（順序を保持）とリモートのみの項目を結合
        merged[year] = [...localItems, ...remoteOnlyItems];
      }

      console.log('同期完了 - マージ後データ:', merged);
      console.log('マージ後データサイズ:', JSON.stringify(merged).length, 'bytes');

      // 3. eraSettingsのマージ処理（ローカルを優先）
      console.log('eraSettings同期前:', { 
        local: eraSettings, 
        localLength: eraSettings.length,
        remote: remoteEraSettings, 
        remoteLength: remoteEraSettings.length 
      });
      
      // ローカルのeraSettingsが存在する場合は必ずそれを使用
      const mergedEraSettings = eraSettings && eraSettings.length > 0 ? eraSettings : remoteEraSettings;
      console.log('eraSettings同期後:', { 
        merged: mergedEraSettings, 
        mergedLength: mergedEraSettings.length 
      });

      // 4. マージしたデータを保存
      console.log('GitHubにデータを保存中...');
      const dataToSave = {
        events: merged,
        eraSettings: mergedEraSettings
      };
      console.log('保存するデータ構造:', {
        hasEvents: !!dataToSave.events,
        eventsKeys: Object.keys(dataToSave.events || {}),
        hasEraSettings: !!dataToSave.eraSettings,
        eraSettingsLength: dataToSave.eraSettings.length,
        eraSettingsContent: dataToSave.eraSettings
      });
      const success = await saveToGitHub(dataToSave);
      if (success) {
        events = merged;
        saveEvents();
        renderEvents();
        
        // 同期完了時刻を記録
        localStorage.setItem('lastSync', new Date().toISOString());
        lastSavedEventsData = JSON.stringify(events); // 自動保存の基準を更新
        updateSyncStatus();
        
        showInfo('同期完了', 'GitHubとの同期が完了しました。');
        console.log('同期処理完了');
      } else {
        console.log('GitHubへの保存に失敗');
      }
    } catch (error) {
      console.error('同期エラーの詳細:', error);
      showError('同期エラー', `同期処理でエラーが発生しました: ${error.message}`);
    }
  }

  // 設定画面
  function showSettings() {
    console.log('showSettings called');
    const settingsHtml = `
      <h4>GitHub同期設定</h4>
      <p>管理者から提供された設定情報を入力してください。</p>
      <div style="margin: 16px 0;">
        <label style="display: block; margin-bottom: 8px;">
          <strong>Personal Access Token:</strong><br>
          <small style="color: #666;">管理者から提供されたトークンを入力</small><br>
          <input type="password" id="accessToken" value="${githubConfig.accessToken}" 
                 style="width: 100%; padding: 6px; margin-top: 4px;" 
                 placeholder="管理者から提供されたトークンを入力" />
        </label>
        <label style="display: block; margin-bottom: 8px;">
          <strong>リポジトリ所有者:</strong><br>
          <small style="color: #666;">通常は「hortense667」</small><br>
          <input type="text" id="owner" value="${githubConfig.owner || 'hortense667'}" 
                 style="width: 100%; padding: 6px; margin-top: 4px;" 
                 placeholder="hortense667" />
        </label>
        <label style="display: block; margin-bottom: 8px;">
          <strong>リポジトリ名:</strong><br>
          <small style="color: #666;">通常は「nativemap」</small><br>
          <input type="text" id="repo" value="${githubConfig.repo || 'nativemap'}" 
                 style="width: 100%; padding: 6px; margin-top: 4px;" 
                 placeholder="nativemap" />
        </label>
        <label style="display: block; margin-bottom: 8px;">
          <strong>ファイルパス:</strong><br>
          <small style="color: #666;">通常は「timeline.json」</small><br>
          <input type="text" id="filePath" value="${githubConfig.filePath || 'timeline.json'}" 
                 style="width: 100%; padding: 6px; margin-top: 4px;" 
                 placeholder="timeline.json" />
        </label>
      </div>
      <div style="margin: 16px 0; padding: 12px; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 6px;">
        <h5>設定情報について:</h5>
        <p style="margin: 8px 0; font-size: 14px;">
          <strong>一般ユーザー:</strong> 管理者（hortense667）から提供された設定情報を入力してください。<br>
          <strong>管理者:</strong> 新しいトークンを生成する場合は、<a href="https://github.com/settings/tokens" target="_blank">GitHub Personal Access Tokens</a>で「repo」スコープを選択してトークンを生成してください。
        </p>
      </div>
      <div style="margin: 16px 0; padding: 12px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px;">
        <h5>データ管理</h5>
        <p style="margin: 8px 0; font-size: 12px; color: #856404;">
          注意: この操作は現在表示されているすべてのデータを削除し、GitHubから最新データを読み込みます。
        </p>
        <button class="btn" onclick="clearAllDataAndReload()" style="background: #dc3545; color: white; border-color: #dc3545;">
          表示中の全ラベルをクリアしてGitHubから読み込み
        </button>
      </div>
      <div style="text-align: right; margin-top: 16px;">
        <button class="btn" onclick="closeModal()">キャンセル</button>
        <button class="btn" onclick="saveSettings()" style="margin-left: 8px;">保存</button>
      </div>
    `;
    openModal('設定', settingsHtml);
  }

  function saveSettings() {
    const tokenInput = document.getElementById('accessToken');
    const ownerInput = document.getElementById('owner');
    const repoInput = document.getElementById('repo');
    const pathInput = document.getElementById('filePath');
    
    if (tokenInput && ownerInput && repoInput && pathInput) {
      githubConfig.accessToken = tokenInput.value.trim();
      githubConfig.owner = ownerInput.value.trim();
      githubConfig.repo = repoInput.value.trim();
      githubConfig.filePath = pathInput.value.trim() || 'timeline.json';
      saveGitHubConfig();
      closeModal();
      showInfo('設定保存', '設定が保存されました。');
    }
  }
  
  // 全データをクリアしてGitHubから読み込み
  async function clearAllDataAndReload() {
    if (!confirm('すべてのデータを削除してGitHubから最新データを読み込みますか？\nこの操作は取り消せません。')) {
      return;
    }
    
    try {
      // 1. 現在のデータをクリア
      events = {};
      saveEvents();
      renderEvents();
      
      // 2. GitHubから最新データを読み込み
      const remoteData = await loadFromGitHub();
      if (remoteData !== null) {
        events = remoteData;
        saveEvents();
        renderEvents();
        
        // 同期完了時刻を記録
        localStorage.setItem('lastSync', new Date().toISOString());
        lastSavedEventsData = JSON.stringify(events);
        updateSyncStatus();
        
        showInfo('データ更新完了', 'GitHubから最新データを読み込みました。');
      } else {
        showError('読み込みエラー', 'GitHubからのデータ読み込みに失敗しました。');
      }
    } catch (error) {
      showError('エラー', `データの更新中にエラーが発生しました: ${error.message}`);
    }
  }
  
  // グローバルに公開
  window.saveSettings = saveSettings;
  window.clearAllDataAndReload = clearAllDataAndReload;

  // 同期状態の表示
  function updateSyncStatus() {
    const lastSync = localStorage.getItem('lastSync');
    const lastEdit = localStorage.getItem('lastEdit');
    
    if (lastEdit && lastEdit > lastSync) {
      // 未同期の変更がある
      syncBtn.style.background = '#ffeb3b';
      syncBtn.style.color = '#000';
      syncBtn.title = '未同期の変更があります - クリックして同期';
    } else {
      // 同期済み
      syncBtn.style.background = '#4caf50';
      syncBtn.style.color = '#fff';
      syncBtn.title = '同期済み';
    }
  }

  // 自動保存機能
  function autoSave() {
    try {
      const currentEvents = JSON.stringify(events);
      if (currentEvents !== lastSavedEventsData) {
        localStorage.setItem('autoSave', currentEvents);
        localStorage.setItem('lastEdit', new Date().toISOString());
        lastSavedEventsData = currentEvents;
        updateSyncStatus();
      }
    } catch (e) {
      console.error('自動保存エラー:', e);
    }
  }

  // 5秒ごとに自動保存
  setInterval(autoSave, 5000);

  // ページを閉じる時の確認
  function checkUnsavedChanges() {
    const lastSync = localStorage.getItem('lastSync');
    const lastEdit = localStorage.getItem('lastEdit');
    
    if (lastEdit && lastSync && lastEdit > lastSync) {
      return '未同期の変更があります。\n\nページを閉じる前に同期することをお勧めします。\n\n本当にページを閉じますか？';
    }
    return null;
  }

  // beforeunloadイベントでページを閉じる前の確認
  window.addEventListener('beforeunload', function(e) {
    const message = checkUnsavedChanges();
    if (message) {
      e.preventDefault();
      e.returnValue = message;
      return message;
    }
  });

  // 初期化時に同期状態を更新
  updateSyncStatus();

  // イベントリスナー
  syncBtn.addEventListener('click', async () => {
    await syncWithConfirmation();
  });
  settingsBtn.addEventListener('click', function() {
    console.log('Settings button clicked');
    showSettings();
  });

  // 初期化時に設定を読み込み
  loadGitHubConfig();

  // ===== CSV/TSV ロード =====
  loadCsvBtn.addEventListener('click', ()=> fileInput.click());
  function detectDelim(sample){ const cntTab=(sample.match(/\t/g)||[]).length; const cntSemi=(sample.match(/;/g)||[]).length; const cntComma=(sample.match(/,/g)||[]).length; const arr=[["\t",cntTab],[";",cntSemi],[",",cntComma]].sort((a,b)=>b[1]-a[1]); return arr[0][1]>0 ? arr[0][0] : ';'; }
  fileInput.addEventListener('change', async (e)=>{ const f=e.target.files && e.target.files[0]; if(!f) return; const text = await f.text(); const {addedCount, errors} = importSeparatedText(text); if(errors.length){ const summary = `正常に追加: ${addedCount} 件`; showError('CSV/TSV読込エラー', [summary, ...errors]); } else if(addedCount>0){ saveEvents(); renderEvents(); showInfo('読み込み完了', `${addedCount} 件を追加しました。`); } else { showInfo('結果', '追加された項目はありませんでした。'); } if(addedCount>0){ saveEvents(); renderEvents(); } fileInput.value=''; });

  function importSeparatedText(text){
    const lines = text.replace(/^\uFEFF/, '').split(/\r?\n/);
    let firstNonEmpty = lines.find(l=>l.trim().length>0) || '';
    const delim = detectDelim(firstNonEmpty);
    let addedCount=0; const errors=[];
    const seen=buildLabelGenreSet();
    for(let i=0;i<lines.length;i++){
      const raw=lines[i].trim(); if(!raw) continue;
      const cols=raw.split(delim);
      if(i===0 && /年/.test(cols[0])) continue;
      if(cols.length<2){ errors.push(`${i+1}行目: 列数不足（年${delim}ラベル${delim}ジャンル${delim}重要度${delim}URL${delim}注釈）`); continue; }
      const yearStr=(cols[0]||'').trim();
      const label=(cols[1]||'').trim();
      const genre=(cols[2]||'').trim().toUpperCase();
      const impStr=(cols[3]||'').trim();
      const url=(cols[4]||'').trim();
      const note=(cols[5]||'').trim();
      const year = parseInt(yearStr,10);
      if(!(yearStr.match(/^\d{4}$/) && year>=YEAR_MIN && year<=YEAR_MAX)){
        errors.push(`${i+1}行目: 年が不正または範囲外（${yearStr}）`); continue;
      }
      if(!label){ errors.push(`${i+1}行目: ラベルが空です`); continue; }
      const key = `${label}|${genre || ''}`;
      if(seen.has(key)) { errors.push(`${i+1}行目: 同じラベル・ジャンル組み合わせが存在します（${label}${genre ? ` [${genre}]` : ''}）`); continue; }
      if(genre && !GENRE_SET.has(genre)){ errors.push(`${i+1}行目: 不正なジャンル（${genre}）`); continue; }
      if(impStr){ const n=parseInt(impStr,10); if(!(n>=1 && n<=5)){ errors.push(`${i+1}行目: 不正な重要度（${impStr}）`); continue; } }
      const item={ label }; if(genre) item.genre=genre; if(impStr) item.imp=parseInt(impStr,10); if(url) item.url=url; if(note) item.note=note;
      if(!events[year]) events[year]=[]; events[year].push(item); seen.add(key); addedCount++;
    }
    return {addedCount, errors};
  }

  // ===== 空年クリックで編集を開く =====
  function openEditorForEmptyYearAt(xCSS,yCSS){ const rect=stage.getBoundingClientRect(); const scale=1; const x=(xCSS-rect.left)/scale; const y=(yCSS-rect.top)/scale; if(x >= ORIGIN_X - HANDLE_LANE_W) return; const year = YEAR_MIN + Math.round((y-ORIGIN_Y)/PX_PER_YEAR); if(year<YEAR_MIN||year>YEAR_MAX) return; const exists = Array.isArray(events[year]) && events[year].length>0; if(exists) return; const anchor=document.createElementNS(ns,'rect'); anchor.setAttribute('x', LABEL_RIGHT_X); anchor.setAttribute('y', yFromBirthYear(year)-6); anchor.setAttribute('width', 1); anchor.setAttribute('height', 12); anchor.setAttribute('fill', 'transparent'); eventsG.appendChild(anchor); showEditor(year, anchor); setTimeout(()=>{ if(anchor.parentNode) anchor.parentNode.removeChild(anchor); }, 0); }
  stage.addEventListener('click', (e)=>{ if(e.target && e.target.tagName && e.target.tagName.toLowerCase()==='text') return; openEditorForEmptyYearAt(e.clientX, e.clientY); });

  // ===== プローブ =====
  function makeProbe(color){
    const g=document.getElementById('probe-'+color);
    const state={eventYear:color==='blue'?1983:1999,birthYear:color==='blue'?1970:1964};
    const stroke=(color==='red'?'#ff3333':'#4da3ff');
    const eventLine=lineEl(ORIGIN_X,0,ORIGIN_X,0); eventLine.style.stroke=stroke; eventLine.style.strokeWidth=3; // 水平（交点まで）
    const vLine=lineEl(0,0,0,ORIGIN_Y);           vLine.style.stroke=stroke; vLine.style.strokeWidth=3; vLine.setAttribute('pointer-events','stroke');
    const diag=lineEl(0,0,0,0);                    diag.style.stroke=stroke;  diag.style.strokeWidth=3; // 左上斜め
    const eh=circleEl(HANDLE_X,0,8,'handle');      eh.setAttribute('stroke',stroke); eh.setAttribute('fill','#fff');
    const bh=circleEl(HANDLE_X,0,8,'handle');      bh.setAttribute('stroke',stroke); bh.setAttribute('fill','#fff');
    // 年齢表示を固定位置のHTML要素として作成
    const ageTextElement = document.createElement('div');
    ageTextElement.style.cssText = `
      position: fixed;
      top: 78px;
      left: 0;
      font-size: 18px;
      font-weight: 700;
      color: #000;
      pointer-events: none;
      z-index: 6;
      display: none;
    `;
    ageTextElement.id = `age-text-${color}`;
    document.body.appendChild(ageTextElement);
    
    const ageText=textEl('',0,0,'ageTickText'); // SVG要素は非表示にする
    const eventYearText=textEl('', ORIGIN_X+8, 0, 'ageTickText'); eventYearText.style.fontSize='14px'; eventYearText.style.fill=stroke; eventYearText.setAttribute('text-anchor','start');
    const birthYearText=textEl('', ORIGIN_X+8, 0, 'ageTickText'); birthYearText.style.fontSize='14px'; birthYearText.style.fill=stroke; birthYearText.setAttribute('text-anchor','start');

    g.append(eventLine,vLine,diag,eh,bh,ageText,eventYearText,birthYearText);

    function redraw(){
      const yE=yFromBirthYear(state.eventYear);
      const yB=yFromBirthYear(state.birthYear);
      const age=Math.max(0,Math.min(AGE_MAX,state.eventYear-state.birthYear));
      const ix=xFromAge(age);
      eventLine.setAttribute('y1',yE);eventLine.setAttribute('y2',yE); eventLine.setAttribute('x1',ORIGIN_X);eventLine.setAttribute('x2',ix);
      vLine.setAttribute('x1',ix);vLine.setAttribute('x2',ix);vLine.setAttribute('y1',yE);vLine.setAttribute('y2',ORIGIN_Y);
      const tMax=Math.max(0,Math.min((ix-ORIGIN_X)/PX_PER_AGE,(yE-ORIGIN_Y)/PX_PER_YEAR));
      diag.setAttribute('x1',ix);diag.setAttribute('y1',yE); diag.setAttribute('x2',ix-PX_PER_AGE*tMax);diag.setAttribute('y2',yE-PX_PER_YEAR*tMax);
      eh.setAttribute('cx',HANDLE_X);eh.setAttribute('cy',yE);
      bh.setAttribute('cx',HANDLE_X);bh.setAttribute('cy',yB);
      // HTML要素の年齢表示を更新（線の右側に表示）
      ageTextElement.textContent = `${age}歳`;
      ageTextElement.style.left = `${ix + 10}px`;
      ageTextElement.style.display = 'block';
      
      // SVG要素は非表示
      ageText.textContent = '';
      eventYearText.textContent = `${state.eventYear}年`;
      eventYearText.setAttribute('x', ORIGIN_X+8);
      eventYearText.setAttribute('y', yE-6);
      const yAtAxis = yE - age*PX_PER_YEAR; const by = Math.round((yAtAxis - ORIGIN_Y)/PX_PER_YEAR) + YEAR_MIN;
      birthYearText.textContent = `${by}年生`;
      birthYearText.style.fill = '#000'; // 生年表示を黒色に
      birthYearText.setAttribute('x', ORIGIN_X+8);
      birthYearText.setAttribute('y', yAtAxis-6);
    }

    function startDrag(){ document.body.classList.add('dragging'); }
    function endDrag(){ document.body.classList.remove('dragging'); }
    function dragByYear(el,prop){ let dragging=false, startY=0, startVal=0; el.addEventListener('mousedown',e=>{ dragging=true; startY=e.clientY; startVal=state[prop]; startDrag(); e.preventDefault(); e.stopPropagation(); }); window.addEventListener('mousemove',e=>{ if(!dragging) return; const dy=e.clientY-startY; const dYear=Math.round(dy/PX_PER_YEAR); state[prop]=Math.max(YEAR_MIN,Math.min(YEAR_MAX,startVal+dYear)); redraw(); }); window.addEventListener('mouseup',()=>{ if(dragging){ dragging=false; endDrag(); } }); }
    dragByYear(eh,'eventYear'); dragByYear(bh,'birthYear'); dragByYear(vLine,'birthYear');

    state.redraw=redraw; redraw(); return state;
  }

  const probeBlue=makeProbe('blue');
  const probeRed=makeProbe('red');

  // ライン表示トグル（小丸ボタン）
  const blueGroup=document.getElementById('probe-blue');
  const redGroup =document.getElementById('probe-red');
  const toggleBlueBtn=document.getElementById('toggleBlue');
  const toggleRedBtn =document.getElementById('toggleRed');
  function setToggle(btn, group, on){ group.style.display = on ? '' : 'none'; btn.setAttribute('aria-pressed', on ? 'true' : 'false'); btn.classList.toggle('off', !on); }
  toggleBlueBtn.addEventListener('click',()=>{ const visible = blueGroup.style.display !== 'none'; setToggle(toggleBlueBtn, blueGroup, !visible); });
  toggleRedBtn.addEventListener('click',()=>{ const visible = redGroup.style.display !== 'none'; setToggle(toggleRedBtn, redGroup, !visible); });

  // フィルタ変更
  function onFilterChange(){ filterImp=selImp.value.trim(); renderEvents(); }
  selImp.addEventListener('change', onFilterChange);
  
  // ジャンル選択モーダル関連の関数
  function showGenreFilterModal() {
    const genreLabels = {
      'ANI': 'アニメ', 'MAN': 'マンガ', 'GAM': 'ゲーム', 'TVP': 'テレビ番組',
      'MOV': '映画', 'NET': 'インターネット', 'HAR': 'ハードウェア', 'PHE': '現象・流行',
      'SOF': 'ソフトウェア', 'TOY': 'おもちゃ', 'FAS': 'ファッション', 'BOO': '本',
      'MAG': '雑誌', 'NOV': '小説', 'MUS': '音楽', 'UNC': 'その他'
    };
    
    let genreButtonsHtml = '';
    for (const genre of GENRES) {
      const isSelected = selectedGenres.has(genre);
      const label = genreLabels[genre] || genre;
      genreButtonsHtml += `
        <button class="genre-btn ${isSelected ? 'selected' : ''}" 
                data-genre="${genre}" 
                onclick="toggleGenre('${genre}')"
                style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; background: ${isSelected ? '#007bff' : '#f9f9f9'}; color: ${isSelected ? 'white' : 'black'};">
          ${label}
        </button>
      `;
    }
    
    const modalContent = `
      <div style="margin-bottom: 16px;">
        <button onclick="selectAllGenres()" style="margin-right: 8px; padding: 6px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">すべてを選択</button>
        <button onclick="deselectAllGenres()" style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">すべてを解除</button>
      </div>
      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 16px;">
        ${genreButtonsHtml}
      </div>
      <div style="text-align: right;">
        <button onclick="applyGenreFilter()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">適用</button>
      </div>
    `;
    
    openModal('ジャンル選択', modalContent);
  }
  
  function toggleGenre(genre) {
    if (selectedGenres.has(genre)) {
      selectedGenres.delete(genre);
    } else {
      selectedGenres.add(genre);
    }
    // ボタンの表示を更新
    const btn = document.querySelector(`[data-genre="${genre}"]`);
    if (btn) {
      const isSelected = selectedGenres.has(genre);
      btn.classList.toggle('selected', isSelected);
      btn.style.background = isSelected ? '#007bff' : '#f9f9f9';
      btn.style.color = isSelected ? 'white' : 'black';
    }
  }
  
  function selectAllGenres() {
    selectedGenres.clear();
    for (const genre of GENRES) {
      selectedGenres.add(genre);
    }
    // すべてのボタンを選択状態に更新
    document.querySelectorAll('.genre-btn').forEach(btn => {
      btn.classList.add('selected');
      btn.style.background = '#007bff';
      btn.style.color = 'white';
    });
  }
  
  function deselectAllGenres() {
    selectedGenres.clear();
    // すべてのボタンを非選択状態に更新
    document.querySelectorAll('.genre-btn').forEach(btn => {
      btn.classList.remove('selected');
      btn.style.background = '#f9f9f9';
      btn.style.color = 'black';
    });
  }
  
  function applyGenreFilter() {
    closeModal();
    renderEvents();
    updateGenreFilterButtonText();
  }
  
  // グローバルスコープで利用できるようにする
  window.toggleGenre = toggleGenre;
  window.selectAllGenres = selectAllGenres;
  window.deselectAllGenres = deselectAllGenres;
  window.applyGenreFilter = applyGenreFilter;
  window.addEraItem = addEraItem;
  window.saveEraSettings = saveEraSettings;
  
  // ジャンルごとの登録件数を計算する関数
  function getGenreCounts() {
    const counts = {};
    const genreLabels = {
      'ANI': 'アニメ', 'MAN': 'マンガ', 'GAM': 'ゲーム', 'TVP': 'テレビ番組',
      'MOV': '映画', 'NET': 'インターネット', 'HAR': 'ハードウェア', 'PHE': '現象・流行',
      'SOF': 'ソフトウェア', 'TOY': 'おもちゃ', 'FAS': 'ファッション', 'BOO': '本',
      'MAG': '雑誌', 'NOV': '小説', 'MUS': '音楽', 'UNC': 'その他'
    };
    
    // 各ジャンルの件数を初期化
    for (const genre of GENRES) {
      counts[genre] = 0;
    }
    
    // 実際のデータから件数を計算
    for (const [year, items] of Object.entries(events)) {
      for (const item of items) {
        const genre = item.genre || 'UNC'; // ジャンル未設定は「その他」
        if (counts.hasOwnProperty(genre)) {
          counts[genre]++;
        }
      }
    }
    
    return counts;
  }
  
  // 総登録件数を取得する関数
  function getTotalItemCount() {
    let total = 0;
    for (const [year, items] of Object.entries(events)) {
      total += items.length;
    }
    return total;
  }
  
  // ジャンル一覧を件数付きで生成する関数
  function generateGenreListWithCounts() {
    const counts = getGenreCounts();
    const genreLabels = {
      'ANI': 'アニメ', 'MAN': 'マンガ', 'GAM': 'ゲーム', 'TVP': 'テレビ番組',
      'MOV': '映画', 'NET': 'インターネット', 'HAR': 'ハードウェア', 'PHE': '現象・流行',
      'SOF': 'ソフトウェア', 'TOY': 'おもちゃ', 'FAS': 'ファッション', 'BOO': '本',
      'MAG': '雑誌', 'NOV': '小説', 'MUS': '音楽', 'UNC': 'その他'
    };
    
    return GENRES.map(genre => {
      const count = counts[genre] || 0;
      const label = genreLabels[genre] || genre;
      return `<li><strong>${genre}:</strong> ${label}（${count}）</li>`;
    }).join('');
  }
  
  function updateGenreFilterButtonText() {
    if (selectedGenres.size === 0) {
      genreFilterBtn.textContent = 'ジャンル選択';
    } else if (selectedGenres.size === GENRES.length) {
      genreFilterBtn.textContent = 'すべてのジャンル';
    } else {
      genreFilterBtn.textContent = `${selectedGenres.size}個のジャンル`;
    }
  }
  
  // ジャンルフィルタボタンのイベントリスナー
  genreFilterBtn.addEventListener('click', showGenreFilterModal);
  
  // 時代区分ボタンのイベントリスナー
  const eraBtn = document.getElementById('eraBtn');
  eraBtn.addEventListener('click', showEraSettingsModal);

  // ヘルプ
  const helpHtml = `
      <h4>使いかたの例（任天堂ファミコン）</h4>
      <p>任天堂のファミコン発売時の年齢を知りたいとします。</p>
      <ol>
        <li><strong>イベント年を合わせる：</strong> ドラッグ専用レーンの<strong>水色の丸</strong>を上下にドラッグして、左カラムのラベル<strong>「83 任天堂ファミコン」</strong>と同じ高さに揃えます。縦軸の内側に <em>「1983年」</em> と表示されます。</li>
        <li><strong>生年を合わせる：</strong> 水色の斜め線の左端（縦軸と交わる位置）近くの<strong>水色の丸</strong>を上下にドラッグして、生年（例：<em>1965年生</em>）に合わせます。上部には <em>「18歳」</em> と表示されます。</li>
      </ol>
      <p>同じ操作は赤い丸（赤色ライン）でも行えます。右上の小さな丸ボタンで各ラインの表示をオン/オフできます。</p>
      <h4>基本操作</h4>
      <ul>
        <li><strong>スクロール：</strong>ホイール／トラックパッド／矢印キー</li>
        <li><strong>ラベル編集：</strong>左カラムの年行をクリック。未登録の年は左カラム空白クリックでエディタを開けます</li>
        <li><strong>検索：</strong>右上の検索欄 → 「検索」「前」「次」。ラベルと注釈の両方を検索対象とします</li>
        <li><strong>表示切替：</strong>「ジャンル」「重要度」フィルタ（重要度は選択値以上のみ表示）</li>
        <li><strong>CSV/TSV読み込み：</strong>「ロード」ボタンで一括データを追加</li>
      </ul>
      <h4>CSV/TSV読み込み形式</h4>
      <p>「ロード」ボタンでCSV/TSVファイルを読み込んで一括でデータを追加できます。</p>
      <p><strong>形式：</strong> <code>年;ジャンル;ラベル;重要度;URL;注釈</code></p>
      <p><strong>例：</strong> <code>1946;HAR;ENIAC;5;https://ja.wikipedia.org/wiki/ENIAC;初の大規模電子計算機</code></p>
      <h5>ジャンル一覧（カッコ内は登録件数／総登録件数：${getTotalItemCount()}件）</h5>
      <ul>
        ${generateGenreListWithCounts()}
      </ul>
      <h5>重要度</h5>
      <ul>
        <li><strong>1:</strong> 参考程度</li>
        <li><strong>2:</strong> やや重要</li>
        <li><strong>3:</strong> 重要</li>
        <li><strong>4:</strong> かなり重要</li>
        <li><strong>5:</strong> 最重要</li>
      </ul>
      <div class="credit">(c) 2025 Satoshi Endo CC-BY 4.0</div>
    `;
  document.getElementById('helpBtn').addEventListener('click', ()=>{ openModal('ヘルプ - ネイティブマップ 1.0', helpHtml); });

  // ===== スモークテスト =====
  function runSmokeTests(){ try { renderEvents(); console.debug('[TEST] renderEvents (clip no-ellipsis): OK'); } catch(e){ console.error('[TEST] renderEvents threw', e); } }
  setTimeout(runSmokeTests, 0);
})();
</script>
</body>
</html>
